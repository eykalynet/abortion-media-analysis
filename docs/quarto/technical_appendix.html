<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-05-06">

<title>Technical Appendix – Abortion News Coverage Before and After Roe v. Wade</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../quarto/images/logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link href="https://fonts.googleapis.com/css2?family=News+Cycle&amp;display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Abortion News Coverage Before and After Roe v. Wade</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../quarto/index.html"> <i class="bi bi-house" role="img">
</i> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../quarto/methodology.html"> <i class="bi bi-gear" role="img">
</i> 
<span class="menu-text">Methodology</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../quarto/technical_appendix.html" aria-current="page"> <i class="bi bi-pc-display-horizontal" role="img">
</i> 
<span class="menu-text">Technical Appendix</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sentiment-calendar" id="toc-sentiment-calendar" class="nav-link active" data-scroll-target="#sentiment-calendar">Sentiment Calendar</a></li>
  <li><a href="#topic-modeling-and-network-visualizations" id="toc-topic-modeling-and-network-visualizations" class="nav-link" data-scroll-target="#topic-modeling-and-network-visualizations">Topic Modeling and Network Visualizations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Technical Appendix</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Last updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 6, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This appendix outlines the technical methodology and implementation details behind each visualization and model used in the blog “Before (and After) Roe v. Wade: A Content Analysis of Conservative and Liberal Media on Abortion Legislation in the United States, 2020–2024.”</p>
<p>The visualizations and models presented in the main blog aim to capture shifting narratives around abortion in the media landscape between 2020 and 2024. However, designing these visual outputs required several additional data wrangling steps and modeling decisions not immediately evident in the main text. This appendix documents those internal decisions to ensure reproducibility.</p>
<section id="sentiment-calendar" class="level2">
<h2 class="anchored" data-anchor-id="sentiment-calendar">Sentiment Calendar</h2>
<p>The sentiment calendar was created to visualize fluctuations in the emotional tone of abortion-related articles across time in a way that captures both daily granularity and broader temporal rhythms. However, several practical challenges emerged. First, articles were published irregularly, with clusters during major events and long stretches without coverage. Second, not every day yielded enough data for reliable sentiment calculation. These gaps, if left untreated, would create abrupt holes in the calendar heatmap and obscure patterns of intensity and tone. Therefore, we introduced a structured calendar sequence spanning from January 1, 2020 to December 31, 2024 and implemented a light-touch imputation process strictly for visualization purposes. For days with no articles, sentiment scores were missing (i.e., <code>NA</code>). To preserve visual continuity in the calendar heatmap without injecting false sentiment, we applied linear interpolation using the <code>zoo::na.approx()</code> function.</p>
<p>Mathematically, linear interpolation estimates the missing sentiment value <span class="math inline">\(s_t\)</span> at time <span class="math inline">\(t\)</span> between two known values <span class="math inline">\(s_{t_1}\)</span> and <span class="math inline">\(s_{t_2}\)</span> as:</p>
<p><span class="math display">\[
s_t = s_{t_1} + \frac{t - t_1}{t_2 - t_1} (s_{t_2} - s_{t_1})
\]</span></p>
<p>This ensures that gaps are filled based on the slope between the two nearest known points. For example, if the sentiment on July 1 is <span class="math inline">\(-2\)</span> and on July 3 is <span class="math inline">\(4\)</span>, then:</p>
<p><span class="math display">\[
s_{\text{July 2}} = -2 + \frac{1}{2}(4 - (-2)) = 1
\]</span></p>
<p>This method is widely used for visual smoothing in time series displays when gaps are not analytically meaningful <span class="citation" data-cites="shumway2017 zeileis2005">(<a href="#ref-shumway2017" role="doc-biblioref">Shumway and Stoffer 2017</a>; <a href="#ref-zeileis2005" role="doc-biblioref">Zeileis and Grothendieck 2005</a>)</span>. We did not use interpolation for any modeling steps but only for visual continuity in <code>geom_tile_interactive()</code> rendering.</p>
<p>Remaining missing values at the edges (i.e., consecutive <code>NA</code>s at the start or end) were conservatively replaced with 0, which we interpret as a neutral baseline rather than evidence of balanced tone.</p>
<p>As a disclaimer, the number of days from 2020 to 2024 totals 1,826. Our dataset includes over 3,100 articles, and because many days have multiple articles, the temporal coverage is dense. Thus, we are confident that linear interpolation did not substantially distort underlying sentiment trends.</p>
<p>We also acknowledge that linear interpolation is a relatively simple method and may not fully explain structural gaps in temporal coverage or non-linear shifts in sentiment dynamics. Ideally, future work would explore more principled approaches from the field of missing data theory, such as time-aware imputation with uncertainty quantification. Hopefully, we can revisit this aspect of our project after taking <a href="https://www.amherst.edu/academiclife/departments/courses/2425F/STAT/STAT-404-2425F">STAT404: <em>Data Not Found: An Introduction to Missing Data Methodology</em></a> taught by our wonderful STAT231: Data Science instructor herself, Prof.&nbsp;Katharine Correia, when it is next offered!</p>
</section>
<section id="topic-modeling-and-network-visualizations" class="level2">
<h2 class="anchored" data-anchor-id="topic-modeling-and-network-visualizations">Topic Modeling and Network Visualizations</h2>
<p>Latent Dirichlet Allocation (LDA) is a generative probabilistic model used to detect latent thematic structures in large text corpora. The term <em>latent</em> refers to the fact that the topics inferred by LDA are not directly observable, but are hidden variables inferred from the co-occurrence patterns in the observed data (i.e., words). LDA assumes that each document <span class="math inline">\(d\)</span> is associated with a topic distribution <span class="math inline">\(\theta_d \sim \text{Dirichlet}(\alpha)\)</span>, and each topic <span class="math inline">\(k\)</span> is associated with a word distribution <span class="math inline">\(\phi_k \sim \text{Dirichlet}(\beta)\)</span>. For every word <span class="math inline">\(w_{d,n}\)</span> in document <span class="math inline">\(d\)</span>, a topic <span class="math inline">\(z_{d,n}\)</span> is first drawn from <span class="math inline">\(\theta_d\)</span>, and a word is then sampled from the corresponding topic’s distribution:</p>
<p><span class="math display">\[
w_{d,n} \sim \text{Multinomial}(\phi_{z_{d,n}})
\]</span></p>
<p>In this formulation, <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are hyperparameters for the Dirichlet priors: <span class="math inline">\(\alpha\)</span> controls the sparsity of topics within a document, and <span class="math inline">\(\beta\)</span> controls the sparsity of words within a topic.</p>
<p>The Dirichlet distribution is a multivariate generalization of the Beta distribution. It generates a probability vector of non-negative real numbers that sum to one. Essentially, a distribution over categories. For instance, if a document is composed of three topics, a sample from a Dirichlet distribution might be <span class="math inline">\((0.7, 0.2, 0.1)\)</span>, indicating the document is 70% about Topic 1, 20% about Topic 2, and 10% about Topic 3. Smaller values of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> (e.g., <span class="math inline">\(&lt; 1\)</span>) yield sparse distributions, where documents concentrate on a few topics and topics on a few words. Larger values (e.g., <span class="math inline">\(&gt; 1\)</span>) yield more uniform distributions. These priors allow LDA to reflect the assumption that documents are usually “about a few things.”</p>
<p>We experimented with values of <span class="math inline">\(k\)</span> ranging from 4 to 12, but due to computational limitations and the exploratory nature of our analysis, we ultimately selected <span class="math inline">\(k = 5\)</span>. This choice also aligns with other media framing studies using LDA in political discourse contexts, such as <span class="citation" data-cites="roberts2014structural">(<a href="#ref-roberts2014structural" role="doc-biblioref">Roberts et al. 2014</a>)</span>, which allows us to balance interpretability with thematic resolution.</p>
<p>After fitting, we extracted topic–term probabilities, denoted <span class="math inline">\(\beta_{k,w} = P(w \mid z = k)\)</span>, using tidytext::tidy(). These represent the probability of word <span class="math inline">\(w\)</span> appearing in topic <span class="math inline">\(k\)</span>, and should not be confused with the Dirichlet prior <span class="math inline">\(\beta\)</span> used in model initialization. We retained terms with <span class="math inline">\(\beta_{k,w} &gt; 0.015\)</span>, to focus on high-association terms, and manually labeled each topic based on its top-ranked terms. For example, a topic dominated by “heartbeat,” “ban,” and “unborn” was labeled Pro-Life Messaging.</p>
<p>To further examine framing differences, we visualized topic structures as bipartite networks using <code>igraph</code> and <code>visNetwork</code>. Nodes represented topics and bigrams, and edges were weighted by <span class="math inline">\(\beta_{k,w}\)</span>. Topic nodes were styled by outlet and time period, using box shapes and consistent color palettes, and interactivity allowed users to trace how themes emerged and diverged across time. Furthermore, one can see that shareed bigrams appeared across multiple topic nodes, which shows recurring rhetorical devices and contested framings that spanned ideological divides.</p>
<p>While LDA is foundational in topic modeling, it is limited by the bag-of-words assumption and fixed topic structures. We look forward to revisiting these questions with more flexible methods, such as dynamic topic models and contextual embeddings, once <a href="https://www.amherst.edu/academiclife/departments/courses/2324S/STAT/STAT-325-2324S">STAT325: Text Analytics</a> is next offered by Prof.&nbsp;Nicholas Horton!</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-roberts2014structural" class="csl-entry" role="listitem">
Roberts, M. E., Stewart, B. M., Tingley, D., Lucas, C., Leder-Luis, J., Gadarian, S. K., Albertson, B., and Rand, D. G. (2014), <span>“Structural topic models for open-ended survey responses,”</span> <em>American Journal of Political Science</em>, 58, 1064–1082. <a href="https://doi.org/10.1111/ajps.12103">https://doi.org/10.1111/ajps.12103</a>.
</div>
<div id="ref-shumway2017" class="csl-entry" role="listitem">
Shumway, R. H., and Stoffer, D. S. (2017), <em>Time series analysis and its applications: With r examples</em>, Springer.
</div>
<div id="ref-zeileis2005" class="csl-entry" role="listitem">
Zeileis, A., and Grothendieck, G. (2005), <span>“Zoo: S3 infrastructure for regular and irregular time series,”</span> <em>Journal of Statistical Software</em>, 14, 1–27.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>